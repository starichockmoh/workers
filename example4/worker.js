self.onmessage = function(event) {
    const { buffer, start, end } = event.data;
    const sharedArray = new Int32Array(buffer);

    for (let i = start; i < end; i++) {
        Atomics.store(sharedArray, i, i * 2); // Используем Atomics для безопасной записи
        // Когда несколько потоков (или воркеров) одновременно читают и пишут в одну и ту же память, могут
        // возникать состояния гонки. В таких состояниях результаты операций могут быть непредсказуемыми и
        // некорректными, так как одно обновление может перезаписать другое.
        // Атомарные операции решают эту проблему, гарантируя, что операции завершатся полностью,
        // без прерываний, и будут выполняться последовательно.

        // Atomics.store(typedArray, index, value): Атомарно сохраняет значение в typedArray по указанному индексу.
    }

    // Уведомляем основной поток о завершении работы
    self.postMessage('done');
};